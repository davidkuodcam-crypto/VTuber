<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM AI èªéŸ³äº’å‹• (é˜²å‘†ç©©å®šç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #2d3748; }
        canvas { display: block; }
        
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        .custom-scroll::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 3px; }
        .drag-over { background-color: rgba(59, 130, 246, 0.5) !important; border: 2px dashed #60a5fa !important; }

        .chat-slide-up { animation: slideUp 0.3s ease-out; }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        .prose p { margin-bottom: 0.5em; }
        .prose strong { color: #93c5fd; }
        .prose blockquote { border-left-color: #60a5fa; background-color: rgba(59, 130, 246, 0.1); padding: 0.5rem; border-radius: 0.25rem; font-size: 0.9em; }

        /* éº¥å…‹é¢¨éŒ„éŸ³å‹•ç•« */
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .mic-active {
            animation: pulse-red 1.5s infinite;
            background-color: #ef4444 !important; /* Red-500 */
        }

        /* æœå°‹æŒ‰éˆ•å•Ÿç”¨å‹•ç•« */
        .search-active {
            color: #60a5fa !important; /* Blue-400 */
            background-color: rgba(30, 58, 138, 0.5) !important;
            box-shadow: 0 0 10px rgba(96, 165, 250, 0.3);
            border: 1px solid #60a5fa;
        }
    </style>
</head>
<body>

    <!-- === å·¦ä¸Šè§’åŠŸèƒ½å€ === -->
    <div class="absolute top-4 left-4 z-[60] flex space-x-2">
        <!-- 1. è¨­å®š API Key -->
        <button id="settings-btn" class="bg-gray-800 text-white p-2 rounded-full shadow-lg hover:bg-gray-700 transition" title="è¨­å®š API Key">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
        </button>

        <!-- 2. è§’è‰²èˆ‡çŸ¥è­˜åº«è¨­å®š -->
        <button id="config-btn" class="bg-gray-800 text-white p-2 rounded-full shadow-lg hover:bg-gray-700 transition relative" title="è¨­å®šè§’è‰²èˆ‡çŸ¥è­˜åº«">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
            <span id="config-status-dot" class="absolute top-0 right-0 h-3 w-3 bg-red-500 rounded-full border-2 border-gray-800 hidden"></span>
        </button>

        <!-- 3. æ›´æ› VRM æ¨¡å‹ -->
        <button id="change-vrm-btn" class="bg-gray-800 text-white p-2 rounded-full shadow-lg hover:bg-gray-700 transition" title="æ›´æ› VRM æ¨¡å‹">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" opacity="0.3" /> 
            </svg>
        </button>
        <input type="file" id="vrm-switch-input" accept=".vrm" class="hidden">

        <!-- 4. ç¶ å¹•åˆ‡æ›æŒ‰éˆ• -->
        <button id="bg-toggle-btn" class="bg-gray-800 text-white p-2 rounded-full shadow-lg hover:bg-gray-700 transition" title="åˆ‡æ›ç¶ å¹•/èƒŒæ™¯">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.343 1.414 1.414M11 7.343l1.657 1.343 1.414-1.414" />
            </svg>
        </button>
    </div>

    <!-- === API Key è¨­å®šçª— === -->
    <div id="settings-modal" class="hidden fixed inset-0 z-[70] flex items-center justify-center bg-black bg-opacity-70 backdrop-blur-sm">
        <div class="bg-gray-800 p-6 rounded-lg shadow-2xl w-96 border border-gray-700">
            <h2 class="text-xl font-bold text-white mb-4 flex items-center">
                <span class="mr-2">âš™ï¸</span> Gemini API è¨­å®š
            </h2>
            <div class="mb-4">
                <label class="block text-gray-400 text-sm mb-2">Google Gemini API Key</label>
                <input type="password" id="api-key-input" placeholder="è«‹è¼¸å…¥ API Key" 
                    class="w-full bg-gray-900 text-white border border-gray-600 rounded px-3 py-2 focus:outline-none focus:border-blue-500 transition">
            </div>
            <div id="connection-status" class="mb-4 text-sm font-semibold h-5"></div>
            <div class="flex justify-end space-x-2">
                <button id="close-settings-btn" class="px-4 py-2 text-gray-400 hover:text-white transition">å–æ¶ˆ</button>
                <button id="save-key-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded transition">å„²å­˜ä¸¦é€£ç·š</button>
            </div>
        </div>
    </div>

    <!-- === è§’è‰²èˆ‡çŸ¥è­˜åº«è¨­å®šè¦–çª— === -->
    <div id="config-modal" class="hidden fixed inset-0 z-[80] flex items-center justify-center bg-black bg-opacity-70 backdrop-blur-sm">
        <div class="bg-gray-900 p-6 rounded-xl shadow-2xl w-[600px] max-h-[80vh] border border-gray-700 flex flex-col">
            <h2 class="text-xl font-bold text-white mb-4 flex items-center border-b border-gray-700 pb-2">
                <span class="mr-2">ğŸ“‚</span> è§’è‰²è¨­å®šèˆ‡çŸ¥è­˜åº«
            </h2>
            
            <div class="flex-1 overflow-y-auto custom-scroll pr-2">
                <!-- 1. è§’è‰² Prompt è¨­å®š -->
                <div class="mb-6">
                    <label class="block text-blue-400 text-sm font-bold mb-2">è§’è‰²æ ¸å¿ƒæŒ‡ä»¤ (Prompt)</label>
                    <p class="text-xs text-gray-400 mb-2">è¨­å®šè§’è‰²çš„å€‹æ€§ã€èªªè©±é¢¨æ ¼ã€æˆ–æ˜¯æ‰®æ¼”çš„èº«åˆ†ã€‚</p>
                    <textarea id="role-prompt-textarea" rows="6" 
                        class="w-full bg-gray-800 text-white border border-gray-600 rounded-lg p-3 text-sm focus:outline-none focus:border-blue-500 transition resize-none leading-relaxed"></textarea>
                </div>

                <!-- 2. çŸ¥è­˜åº«åˆ—è¡¨ -->
                <div class="mb-2">
                    <div class="flex justify-between items-center mb-2">
                        <label class="block text-green-400 text-sm font-bold">å¤–æ›çŸ¥è­˜åº«æª”æ¡ˆ</label>
                        <button id="add-kb-btn" class="text-xs bg-gray-700 hover:bg-gray-600 text-white px-2 py-1 rounded flex items-center transition">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                            </svg>
                            æ–°å¢æª”æ¡ˆ (.txt/.md)
                        </button>
                        <input type="file" id="kb-file-input" accept=".txt,.md" class="hidden" multiple>
                    </div>
                    
                    <div id="kb-list-container" class="space-y-2 min-h-[100px] bg-gray-800 rounded-lg p-2 border border-gray-700">
                        <div id="empty-kb-msg" class="text-center text-gray-500 text-sm py-4 italic">å°šæœªè¼‰å…¥ä»»ä½•çŸ¥è­˜åº«æª”æ¡ˆ</div>
                    </div>
                </div>
            </div>

            <!-- åº•éƒ¨æŒ‰éˆ• -->
            <div class="flex justify-end space-x-3 mt-6 pt-4 border-t border-gray-700">
                <button id="cancel-config-btn" class="px-4 py-2 text-gray-400 hover:text-white transition rounded-lg hover:bg-gray-800">å–æ¶ˆ</button>
                <button id="apply-config-btn" class="px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-lg shadow-lg transform active:scale-95 transition">
                    å„²å­˜ä¸¦å¥—ç”¨è¨­å®š
                </button>
            </div>
        </div>
    </div>

    <!-- === èŠå¤©å°è©±å€ === -->
    <div id="chat-container" class="absolute bottom-0 left-0 right-0 z-30 p-4 transition-transform duration-300">
        <div id="chat-history" class="max-w-2xl mx-auto h-[30vh] overflow-y-auto mb-4 custom-scroll space-y-3 px-4 pb-2 flex flex-col-reverse">
            <div class="text-center text-gray-500 text-sm bg-gray-800 bg-opacity-50 rounded-lg p-2 mx-auto inline-block backdrop-blur-sm">
                è¨­å®š API Key å¾Œï¼Œé»æ“Šéº¥å…‹é¢¨æˆ–è¼¸å…¥æ–‡å­—é–‹å§‹äº’å‹•
            </div>
        </div>

        <div class="max-w-2xl mx-auto flex flex-col items-center">
            <div id="status-indicator" class="text-xs text-blue-300 mb-1 h-4 font-bold tracking-wider opacity-0 transition-opacity duration-300"></div>

            <div class="w-full bg-gray-900 bg-opacity-90 p-2 rounded-full shadow-2xl flex items-center border border-gray-700 backdrop-blur-md">
                <!-- éº¥å…‹é¢¨ -->
                <button id="mic-btn" disabled class="bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-full mr-2 transition disabled:opacity-50 disabled:cursor-not-allowed flex-shrink-0 relative" title="èªéŸ³è¼¸å…¥ (æŒçºŒè†è½)">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd" />
                    </svg>
                </button>

                <!-- è¯ç¶²æœå°‹ (åœ°çƒåœ–ç¤º) -->
                <button id="search-toggle-btn" disabled class="bg-gray-700 text-gray-400 hover:text-white p-2 rounded-full mr-2 transition disabled:opacity-50 disabled:cursor-not-allowed flex-shrink-0" title="é–‹å•Ÿ/é—œé–‰ è¯ç¶²æœå°‹ (å¼·åˆ¶æŸ¥è³‡æ–™)">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9" />
                    </svg>
                </button>

                <input type="text" id="chat-input" placeholder="è¼¸å…¥è¨Šæ¯..." disabled
                    class="flex-1 bg-transparent text-white px-4 py-2 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50">
                
                <button id="send-btn" disabled class="bg-blue-600 hover:bg-blue-500 text-white p-2 rounded-full ml-2 transition disabled:bg-gray-700 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-90" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" />
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- è¼‰å…¥ç•«é¢ -->
    <div id="status-screen" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-gray-900 text-white transition-opacity duration-500">
        <div id="loading-spinner" class="hidden flex-col items-center">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500 mb-4"></div>
            <p id="loading-text" class="text-xl font-bold">æ­£åœ¨è®€å– VRM æ¨¡å‹...</p>
        </div>
        <div id="upload-prompt" class="flex flex-col items-center text-center p-8 border-2 border-dashed border-gray-600 rounded-xl bg-gray-800 bg-opacity-50">
            <p class="text-2xl font-bold mb-2">è«‹è¼‰å…¥æ¨¡å‹</p>
            <p class="text-gray-400 mb-6 max-w-md">æ”¯æ´ VRM 0.0 èˆ‡ 1.0<br>æ‹–æ”¾æª”æ¡ˆæˆ–é»æ“Šä¸‹æ–¹æŒ‰éˆ•</p>
            <label class="cursor-pointer bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-full transition shadow-lg hover:scale-105">
                é¸æ“‡æª”æ¡ˆ <input type="file" id="center-file-input" accept=".vrm" class="hidden" />
            </label>
        </div>
    </div>

    <div id="canvas-container" class="w-full h-screen"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
                "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        let currentVrm = null;
        let scene, camera, renderer, clock;
        let gridHelper; 
        let apiKey = localStorage.getItem('gemini_api_key') || '';
        let chatHistory = [];
        let isSpeaking = false; 
        let speechSynth = window.speechSynthesis;
        let speakingSafetyTimer = null; 
        
        let blinkTimer = 0;
        let nextBlinkTime = 3;
        let autoBlinkEnabled = true; 
        let currentEmotion = null; 
        
        // === ç¶ å¹•èˆ‡èƒŒæ™¯è®Šæ•¸ ===
        let isGreenScreen = false;

        // === èªéŸ³è¾¨è­˜è®Šæ•¸ ===
        let recognition = null;
        let isListening = false; 
        let isRecognitionActive = false; 
        let silenceTimer = null;
        const SILENCE_DELAY = 1500; 
        let watchdogInterval = null; // çœ‹é–€ç‹—è¨ˆæ™‚å™¨
        
        const GEMINI_MODEL = 'gemini-2.5-flash-preview-09-2025';

        // === æœå°‹èˆ‡æç¤ºè©è®Šæ•¸ ===
        let isSearchEnabled = false; 
        const DEFAULT_SYSTEM_PROMPT = `ä½ ç¾åœ¨æ˜¯ä¸€å€‹è™›æ“¬çš„ 3D å‹•æ¼«è§’è‰²ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚
ä½ çš„å€‹æ€§æ´»æ½‘ã€å‹å–„ä¸”å¸¶é»èª¿çš®ã€‚å›ç­”è«‹ç›¡é‡ç°¡çŸ­ï¼ˆå…©ä¸‰å¥è©±ä»¥å…§ï¼‰ã€‚
è«‹ä¸è¦ä½¿ç”¨ markdown æ ¼å¼çš„åˆ—è¡¨ï¼Œç›¡é‡å£èªåŒ–ã€‚

ã€é‡è¦ï¼šæƒ…ç·’èˆ‡è¡¨æƒ…æ§åˆ¶æŒ‡ä»¤ã€‘
è«‹åœ¨æ¯æ¬¡å›ç­”çš„ã€Œæœ€é–‹é ­ã€ï¼Œç”¨ä¸­æ‹¬è™Ÿæ¨™è¨»ä½ ç•¶ä¸‹çš„è¡¨æƒ…æˆ–å‹•ä½œã€‚

1. ä¸€èˆ¬æƒ…ç·’æ¨™ç±¤ (é è¨­è¡¨æƒ…ï¼Œéœæ…‹)ï¼š
[neutral], [joy], [angry], [sorrow], [fun], [surprised]

2. é€²éšå‹•ä½œæŒ‡ä»¤ (Action - åŸ·è¡Œå‹•ç•«)ï¼š
å¦‚æœä½¿ç”¨è€…è¦æ±‚ã€Œçœ¨çœ¼ã€ã€ã€Œè¼ªæµé–‰çœ¼ã€ã€ã€Œé»é ­ã€ï¼Œè«‹ä½¿ç”¨ä»¥ä¸‹æŒ‡ä»¤ï¼š
[action:wink_left]  - å–®çœ¼çœ¨ (å·¦)
[action:wink_right] - å–®çœ¼çœ¨ (å³)
[action:wink_alternate] - è¼ªæµé–‰çœ¼ (å·¦ä¸€ä¸‹å³ä¸€ä¸‹)
[action:nod] - é»é ­

3. å®¢è£½åŒ–è‡‰éƒ¨æ§åˆ¶ (éœæ…‹)ï¼š
æ ¼å¼ï¼š[face:åƒæ•¸=æ•¸å€¼,åƒæ•¸=æ•¸å€¼]
å¯ç”¨åƒæ•¸ï¼šblink_l, blink_r, blink, aa, ih, ou, ee, oh

ç¯„ä¾‹ï¼š
"[action:wink_alternate] å¥½å–”ï¼çœ‹æˆ‘çš„è¼ªæµé–‰çœ¼ï¼"
"[action:wink_left] å•¾å’ªï¼"
"[joy] å“ˆå“ˆï¼å¤ªå¥½ç¬‘äº†ï¼"

è«‹å‹™å¿…éµå®ˆæ­¤æ ¼å¼ï¼Œä¸è¦å°‡æ¨™ç±¤å”¸å‡ºä¾†ã€‚`;
        
        let rolePromptSettings = DEFAULT_SYSTEM_PROMPT;
        let knowledgeBaseFiles = []; 

        // === IndexedDB è¨­å®š ===
        const DB_NAME = 'VRM_Store';
        const DB_VERSION = 1;
        const STORE_NAME = 'models';

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    e.target.result.createObjectStore(STORE_NAME);
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e);
            });
        }

        async function saveModelToDB(file) {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                store.put(file, 'current_vrm');
                return new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            } catch (e) {
                console.error("å„²å­˜æ¨¡å‹ä¾‹å¤–éŒ¯èª¤:", e);
                if (e.name === 'QuotaExceededError') alert("å„²å­˜å¤±æ•—ï¼šç€è¦½å™¨å„²å­˜ç©ºé–“ä¸è¶³ã€‚");
            }
        }

        async function getModelFromDB() {
            try {
                const db = await openDB();
                return new Promise((resolve) => {
                    const tx = db.transaction(STORE_NAME, 'readonly');
                    const req = tx.objectStore(STORE_NAME).get('current_vrm');
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => resolve(null);
                });
            } catch (e) {
                console.error("è®€å–æ¨¡å‹å¤±æ•—:", e);
                return null;
            }
        }

        async function init() {
            setupScene();
            setupUI();
            setupChat();
            setupConfigManager(); 
            setupKeyboardShortcuts(); 
            
            // å•Ÿå‹•çœ‹é–€ç‹—ï¼Œç›£æ§èªéŸ³è¾¨è­˜å¥åº·ç‹€æ³
            startWatchdog();

            if(apiKey) {
                document.getElementById('api-key-input').value = apiKey;
                enableChat(true);
            }

            const cachedFile = await getModelFromDB();
            if (cachedFile) {
                const loadingText = document.getElementById('loading-text');
                if(loadingText) loadingText.textContent = "æ­£åœ¨é‚„åŸä¸Šæ¬¡çš„è§’è‰²...";
                loadVRM(URL.createObjectURL(cachedFile)); 
            }

            animate();
        }

        function setupKeyboardShortcuts() {
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (speechSynth.speaking || isSpeaking) {
                        stopSpeakingForcefully();
                        addChatMessage('system', 'ğŸ›‘ å·²ä¸­æ–·èªéŸ³å›ç­”');
                    }
                    if (isListening) stopListening();
                }
            });
        }

        function setupScene() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202025);
            gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
            scene.add(gridHelper);

            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 20.0);
            camera.position.set(0.0, 1.5, 1.25); 
            
            const light = new THREE.DirectionalLight(0xffffff, 1.2);
            light.position.set(1.0, 1.0, 1.0).normalize();
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.screenSpacePanning = true;
            controls.target.set(0.0, 1.5, 0.0);
            controls.update();

            clock = new THREE.Clock();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setupConfigManager() {
            const modal = document.getElementById('config-modal');
            const openBtn = document.getElementById('config-btn');
            const cancelBtn = document.getElementById('cancel-config-btn');
            const applyBtn = document.getElementById('apply-config-btn');
            const kbFileInput = document.getElementById('kb-file-input');
            const addKbBtn = document.getElementById('add-kb-btn');
            const promptTextarea = document.getElementById('role-prompt-textarea');
            const statusDot = document.getElementById('config-status-dot');

            openBtn.onclick = () => {
                promptTextarea.value = rolePromptSettings;
                renderKnowledgeList();
                modal.classList.remove('hidden');
            };
            cancelBtn.onclick = () => modal.classList.add('hidden');

            addKbBtn.onclick = () => kbFileInput.click();
            kbFileInput.onchange = (e) => {
                const files = Array.from(e.target.files);
                let loadedCount = 0;
                files.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        knowledgeBaseFiles.push({
                            id: Date.now() + Math.random(),
                            name: file.name,
                            content: event.target.result
                        });
                        loadedCount++;
                        if (loadedCount === files.length) renderKnowledgeList();
                    };
                    reader.readAsText(file);
                });
                kbFileInput.value = ''; 
            };

            window.deleteKnowledgeFile = (id) => {
                knowledgeBaseFiles = knowledgeBaseFiles.filter(f => f.id !== id);
                renderKnowledgeList();
            };

            function renderKnowledgeList() {
                const container = document.getElementById('kb-list-container');
                container.innerHTML = '';
                if (knowledgeBaseFiles.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-500 text-sm py-4 italic">å°šæœªè¼‰å…¥ä»»ä½•çŸ¥è­˜åº«æª”æ¡ˆ</div>';
                } else {
                    knowledgeBaseFiles.forEach(file => {
                        const item = document.createElement('div');
                        item.className = "flex justify-between items-center bg-gray-700 p-2 rounded border border-gray-600 text-sm animate-fade-in";
                        item.innerHTML = `
                            <span class="text-gray-200 truncate flex-1 mr-2" title="${file.name}">ğŸ“„ ${file.name}</span>
                            <button onclick="deleteKnowledgeFile(${file.id})" class="text-gray-400 hover:text-red-400 p-1 hover:bg-gray-600 rounded transition" title="åˆªé™¤æª”æ¡ˆ">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        `;
                        container.appendChild(item);
                    });
                }
            }

            applyBtn.onclick = () => {
                const newPrompt = promptTextarea.value.trim();
                if (!newPrompt) { alert("è§’è‰²æ ¸å¿ƒæŒ‡ä»¤ä¸èƒ½ç‚ºç©ºï¼"); return; }
                rolePromptSettings = newPrompt;
                statusDot.classList.remove('hidden', 'bg-red-500');
                statusDot.classList.add('bg-green-500');
                addChatMessage('system', `âœ… è¨­å®šå·²æ›´æ–° (å« ${knowledgeBaseFiles.length} å€‹çŸ¥è­˜åº«æª”æ¡ˆ)`);
                chatHistory = [];
                modal.classList.add('hidden');
            };
        }

        function buildFullSystemPrompt() {
            let fullPrompt = rolePromptSettings;
            if (knowledgeBaseFiles.length > 0) {
                fullPrompt += "\n\n=== å¤–éƒ¨çŸ¥è­˜åº«è³‡æ–™ ===\n";
                knowledgeBaseFiles.forEach((file, index) => {
                    fullPrompt += `\n--- æ–‡ä»¶ ${index + 1}: ${file.name} ---\n${file.content}\n`;
                });
                fullPrompt += "\n=== çŸ¥è­˜åº«çµæŸ ===\n";
            }
            return fullPrompt;
        }

        async function handleVRMSelect(file) {
            addChatMessage('system', 'ğŸ’¾ æ­£åœ¨å¿«å–æ¨¡å‹è³‡æ–™...');
            await saveModelToDB(file);
            addChatMessage('system', 'âœ… æ¨¡å‹å·²å‚™ä»½');
            loadVRM(URL.createObjectURL(file)); 
        }

        function setupUI() {
            const modal = document.getElementById('settings-modal');
            const statusText = document.getElementById('connection-status');
            
            document.getElementById('settings-btn').onclick = () => { modal.classList.remove('hidden'); statusText.textContent = ''; };
            document.getElementById('close-settings-btn').onclick = () => modal.classList.add('hidden');

            document.getElementById('save-key-btn').onclick = async () => {
                const inputKey = document.getElementById('api-key-input').value.trim();
                if (!inputKey) return;
                statusText.textContent = 'é€£ç·šæ¸¬è©¦ä¸­...';
                statusText.className = 'mb-4 text-sm font-semibold h-5 text-yellow-500';

                const isValid = await testGeminiConnection(inputKey);
                if (isValid) {
                    apiKey = inputKey;
                    localStorage.setItem('gemini_api_key', apiKey);
                    statusText.textContent = 'é€£ç·šæˆåŠŸï¼';
                    statusText.className = 'mb-4 text-sm font-semibold h-5 text-green-500';
                    enableChat(true);
                    setTimeout(() => modal.classList.add('hidden'), 1000);
                } else {
                    statusText.textContent = 'é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥ Keyã€‚';
                    statusText.className = 'mb-4 text-sm font-semibold h-5 text-red-500';
                    enableChat(false);
                }
            };

            document.getElementById('change-vrm-btn').onclick = () => document.getElementById('vrm-switch-input').click();
            document.getElementById('vrm-switch-input').onchange = (e) => { if(e.target.files[0]) handleVRMSelect(e.target.files[0]); };

            document.getElementById('bg-toggle-btn').onclick = () => {
                isGreenScreen = !isGreenScreen;
                if (isGreenScreen) {
                    scene.background = new THREE.Color(0x00FF00);
                    gridHelper.visible = false;
                    addChatMessage('system', 'ğŸ¨ å·²åˆ‡æ›ç‚ºç¶ å¹•æ¨¡å¼');
                } else {
                    scene.background = new THREE.Color(0x202025);
                    gridHelper.visible = true;
                    addChatMessage('system', 'ğŸ¨ å·²é‚„åŸæ·±è‰²èƒŒæ™¯');
                }
            };

            const dropZone = document.body;
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); document.getElementById('status-screen').classList.add('drag-over'); });
            dropZone.addEventListener('dragleave', () => document.getElementById('status-screen').classList.remove('drag-over'));
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                document.getElementById('status-screen').classList.remove('drag-over');
                if (e.dataTransfer.files[0]?.name.endsWith('.vrm')) handleVRMSelect(e.dataTransfer.files[0]);
            });
            document.getElementById('center-file-input').addEventListener('change', (e) => { if(e.target.files[0]) handleVRMSelect(e.target.files[0]); });
            
            document.getElementById('mic-btn').onclick = () => {
                if (isListening) stopListening();
                else startListening();
            };
        }

        // === èªéŸ³è¾¨è­˜ (Watchdog & Recovery) ===
        function updateStatus(text) {
            const el = document.getElementById('status-indicator');
            if(text) {
                el.textContent = text;
                el.style.opacity = '1';
            } else {
                el.style.opacity = '0';
            }
        }

        // çœ‹é–€ç‹—ï¼šç¢ºä¿è¾¨è­˜ç³»çµ±æ²’æœ‰ã€Œå‡æ­»ã€
        function startWatchdog() {
            if (watchdogInterval) clearInterval(watchdogInterval);
            watchdogInterval = setInterval(() => {
                // å¦‚æœæˆ‘å€‘ã€Œæ‡‰è©²ã€è¦è½ï¼Œä½†è¾¨è­˜ç³»çµ±å»ä¸åœ¨é‹ä½œ (isRecognitionActive = false)
                // æˆ–è€…è¾¨è­˜ç³»çµ±ä»¥ç‚ºåœ¨è·‘ï¼Œä½†å·²ç¶“å¾ˆä¹…æ²’åæ‡‰ (é€™å€‹æ¯”è¼ƒé›£åµæ¸¬ï¼Œå…ˆæŠ“å·²åœæ­¢çš„ç‹€æ³)
                if (isListening && !isRecognitionActive) {
                    console.warn("Watchdog: Recognition is stuck (should be listening but inactive). Restarting...");
                    restartRecognitionSystem();
                }
            }, 2000); // æ¯ 2 ç§’æª¢æŸ¥ä¸€æ¬¡
        }

        function createRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.warn("Speech Recognition not supported");
                alert("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è¾¨è­˜ï¼Œè«‹ä½¿ç”¨ Chrome");
                return null;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const rec = new SpeechRecognition();
            rec.continuous = true; 
            rec.interimResults = true; 
            rec.lang = 'zh-TW';

            const input = document.getElementById('chat-input');
            const micBtn = document.getElementById('mic-btn');

            rec.onstart = () => {
                console.log("Recognition Started");
                isRecognitionActive = true; 
                micBtn.classList.add('mic-active');
                if (!isSpeaking) updateStatus("ğŸ‘‚ æ­£åœ¨è†è½...");
                input.placeholder = "è«‹èªªè©±...";
            };
            
            rec.onspeechstart = () => {
                 // å¼·åˆ¶è§£é–æª¢æŸ¥ï¼šå¦‚æœç³»çµ±ä»¥ç‚º AI åœ¨è¬›è©±ï¼Œä½†ç€è¦½å™¨èªªæ²’æœ‰ï¼Œå°±è§£é–
                 if (isSpeaking && !window.speechSynthesis.speaking) {
                     console.log("Force unlocking isSpeaking state (SpeechStart detected but synth silent)");
                     isSpeaking = false;
                 }
                 
                 if (!isSpeaking) updateStatus("ğŸ”Š åµæ¸¬åˆ°è²éŸ³...");
            };

            rec.onend = () => {
                console.log("Recognition Ended");
                isRecognitionActive = false; 
                
                if (isListening) {
                    // å¦‚æœæ˜¯æ„å¤–æ–·ç·šï¼ŒWatchdog æœƒæ¥æ‰‹ï¼Œæˆ–è€…é€™è£¡å»¶é²é‡å•Ÿ
                    setTimeout(() => {
                        if (isListening && !isRecognitionActive) {
                            console.log("Restarting from onend...");
                            restartRecognitionSystem();
                        }
                    }, 500); // å¢åŠ å»¶é²åˆ° 500msï¼Œé¿å…éå¿«é‡å•Ÿ
                } else {
                    micBtn.classList.remove('mic-active');
                    updateStatus("");
                    input.placeholder = "è¼¸å…¥è¨Šæ¯...";
                }
            };

            rec.onresult = (event) => {
                // å¼·åˆ¶è§£é–æª¢æŸ¥
                if (isSpeaking && !window.speechSynthesis.speaking) {
                     console.log("Force unlocking isSpeaking state (Result received but synth silent)");
                     isSpeaking = false;
                }

                if (isSpeaking) {
                    console.log("Input ignored: AI is speaking");
                    return;
                }

                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript;
                    else interimTranscript += event.results[i][0].transcript;
                }

                const currentText = finalTranscript || interimTranscript;
                if (currentText) {
                    input.value = currentText;
                    if (silenceTimer) clearTimeout(silenceTimer);
                    silenceTimer = setTimeout(() => {
                        console.log("åµæ¸¬åˆ°éœéŸ³ï¼Œç™¼é€è¨Šæ¯");
                        sendMessage(); 
                    }, SILENCE_DELAY);
                }
            };

            rec.onerror = (event) => {
                console.error("Speech Error:", event.error);
                if (['not-allowed', 'service-not-allowed'].includes(event.error)) {
                    isListening = false;
                    micBtn.classList.remove('mic-active');
                    updateStatus("âš ï¸ èªéŸ³å­˜å–è¢«æ‹’");
                    input.placeholder = "èªéŸ³éŒ¯èª¤: " + event.error;
                }
                // 'no-speech' error is ignored as it's common in continuous mode
            };
            
            return rec;
        }

        // å¼·åˆ¶éŠ·æ¯€ä¸¦é‡å»ºè¾¨è­˜ç³»çµ± (Deep Clean)
        function restartRecognitionSystem() {
            if (recognition) {
                // ç§»é™¤æ‰€æœ‰ç›£è½å™¨ï¼Œé˜²æ­¢èˆŠç‰©ä»¶å¾©æ´»
                recognition.onend = null;
                recognition.onerror = null;
                recognition.onresult = null;
                recognition.onstart = null;
                recognition.onspeechstart = null;
                
                try { recognition.stop(); } catch(e){}
                try { recognition.abort(); } catch(e){}
                recognition = null;
            }
            
            // ç¨å¾…ç‰‡åˆ»å†å»ºç«‹ï¼Œç¢ºä¿ç€è¦½å™¨é‡‹æ”¾è³‡æº
            setTimeout(() => {
                if (isListening) {
                    recognition = createRecognition();
                    if (recognition) {
                        try { recognition.start(); } catch(e) { console.error("Re-start failed:", e); }
                    }
                }
            }, 200);
        }

        function startListening() {
            if (isRecognitionActive) return; 
            
            // ç¢ºä¿ä¹¾æ·¨çš„é–‹å§‹
            if (!recognition) recognition = createRecognition();

            try {
                isListening = true;
                recognition.start();
            } catch (e) { 
                console.error("Start listening failed, recreating...", e);
                restartRecognitionSystem();
            }
        }

        function stopListening() {
            isListening = false;
            if (recognition) {
                recognition.stop();
            }
            document.getElementById('mic-btn').classList.remove('mic-active');
            updateStatus("");
        }
        
        function stopSpeakingForcefully() {
             isSpeaking = false;
             speechSynth.cancel();
             if (speakingSafetyTimer) clearTimeout(speakingSafetyTimer);
             
             if(currentVrm && currentVrm.expressionManager) {
                currentVrm.expressionManager.setValue('aa', 0);
                resetEmotions(currentVrm); 
                autoBlinkEnabled = true;
             }
             if (isListening) updateStatus("ğŸ‘‚ æ­£åœ¨è†è½...");
        }

        function setupChat() {
            const input = document.getElementById('chat-input');
            const sendBtn = document.getElementById('send-btn');
            const searchBtn = document.getElementById('search-toggle-btn');

            searchBtn.onclick = () => {
                isSearchEnabled = !isSearchEnabled;
                if (isSearchEnabled) {
                    searchBtn.classList.add('search-active');
                    addChatMessage('system', 'ğŸŒ å·²é–‹å•Ÿè¯ç¶²æœå°‹åŠŸèƒ½');
                } else {
                    searchBtn.classList.remove('search-active');
                    addChatMessage('system', 'ğŸŒ å·²é—œé–‰è¯ç¶²æœå°‹åŠŸèƒ½');
                }
            };

            window.sendMessage = async () => {
                const text = input.value.trim();
                if (!text || !apiKey) return;
                
                if (silenceTimer) clearTimeout(silenceTimer);

                addChatMessage('user', text);
                input.value = '';
                
                try {
                    const loadingId = addChatMessage('model', '...', true);
                    const rawResponseText = await callGeminiAPI(text);
                    document.getElementById(loadingId).remove();
                    processResponse(rawResponseText);
                } catch (error) {
                    console.error(error);
                    addChatMessage('system', `éŒ¯èª¤: ${error.message}`);
                } finally {
                    input.focus();
                }
            };

            sendBtn.onclick = window.sendMessage;
            input.onkeypress = (e) => { if (e.key === 'Enter') window.sendMessage(); };
        }

        function processResponse(rawText) {
            let displayText = rawText;
            let emotionSet = false;
            autoBlinkEnabled = true;

            const actionRegex = /\[action:([^\]]+)\]/gi;
            displayText = displayText.replace(actionRegex, (match, actionName) => {
                triggerAction(currentVrm, actionName);
                emotionSet = true;
                return ''; 
            });

            const faceRegex = /\[face:([^\]]+)\]/gi;
            displayText = displayText.replace(faceRegex, (match, params) => {
                applyCustomFace(currentVrm, params); 
                emotionSet = true; 
                return ''; 
            });

            const emotionRegex = /\[(joy|angry|sorrow|fun|surprised|neutral)\]/gi;
            displayText = displayText.replace(emotionRegex, (match, emotion) => {
                if (!emotionSet) {
                    setEmotion(currentVrm, emotion.toLowerCase());
                    emotionSet = true;
                }
                return ''; 
            });

            if (!emotionSet) {
                if (rawText.match(/å“ˆå“ˆ|é–‹å¿ƒ|é«˜èˆˆ|å–œæ­¡|æ£’|è®š|æœ‰è¶£/)) setEmotion(currentVrm, 'joy');
                else if (rawText.match(/ç”Ÿæ°£|è¨å­|æ€’|æ»¾|ç…©/)) setEmotion(currentVrm, 'angry');
                else if (rawText.match(/é›£é|å—šå—š|å“­|å‚·å¿ƒ|éºæ†¾|æŠ±æ­‰/)) setEmotion(currentVrm, 'sorrow');
                else if (rawText.match(/é©š|åš‡|å“‡|å¤©å•Š|å’¦/)) setEmotion(currentVrm, 'surprised');
            }

            displayText = displayText.replace(/\s{2,}/g, ' ').trim();
            addChatMessage('model', displayText);
            speak(displayText);
        }

        function triggerAction(vrm, actionName) {
            if (!vrm || !vrm.expressionManager) return;
            resetEmotions(vrm);
            autoBlinkEnabled = false; 

            if (actionName === 'wink_left') performWink(vrm, 'blinkLeft');
            else if (actionName === 'wink_right') performWink(vrm, 'blinkRight');
            else if (actionName === 'wink_alternate') {
                performWink(vrm, 'blinkLeft');
                setTimeout(() => performWink(vrm, 'blinkRight'), 600);
            } else if (actionName === 'nod') setEmotion(vrm, 'joy');

            setTimeout(() => { autoBlinkEnabled = true; }, 1500);
        }

        function performWink(vrm, target) {
            const expressionName = target === 'blinkLeft' ? (vrm.expressionManager.getExpression('blinkLeft') ? 'blinkLeft' : 'blink_l') : 
                                   (vrm.expressionManager.getExpression('blinkRight') ? 'blinkRight' : 'blink_r');
            
            if (vrm.expressionManager.getExpression(expressionName)) {
                vrm.expressionManager.setValue(expressionName, 1.0);
                setTimeout(() => vrm.expressionManager.setValue(expressionName, 0.0), 200);
            }
        }

        function applyCustomFace(vrm, paramString) {
            if (!vrm || !vrm.expressionManager) return;
            resetEmotions(vrm);
            
            const pairs = paramString.split(',');
            let eyesClosed = false;

            pairs.forEach(pair => {
                const [key, valStr] = pair.split('=').map(s => s.trim());
                const val = parseFloat(valStr);
                if (isNaN(val)) return;

                let target = key.toLowerCase();
                const candidates = [target];
                if (target === 'blink_l') candidates.push('blinkLeft');
                if (target === 'blink_r') candidates.push('blinkRight');
                if (target === 'blink') candidates.push('blink'); 
                if (target === 'aa') candidates.push('aa');
                if (target === 'ih') candidates.push('ih');
                if (target === 'ou') candidates.push('ou');
                if (target === 'ee') candidates.push('ee');
                if (target === 'oh') candidates.push('oh');
                
                for (const c of candidates) {
                    if (vrm.expressionManager.getExpression(c)) {
                        vrm.expressionManager.setValue(c, val);
                        break;
                    }
                }
                if (target.includes('blink')) eyesClosed = true;
            });

            autoBlinkEnabled = !eyesClosed; 
        }

        async function callGeminiAPI(userText) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;
            const historyContents = chatHistory.slice(-10).map(msg => ({
                role: msg.role === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text }]
            }));
            historyContents.push({ role: "user", parts: [{ text: userText }] });

            let effectiveSystemPrompt = buildFullSystemPrompt();
            if (isSearchEnabled) {
                effectiveSystemPrompt += "\n[ç³»çµ±æŒ‡ä»¤ï¼šä½¿ç”¨è€…å·²é–‹å•Ÿè¯ç¶²æœå°‹åŠŸèƒ½ã€‚è«‹å‹™å¿…ä½¿ç”¨ Google Search å·¥å…·æŸ¥æ‰¾æœ€æ–°ã€æœ€å³æ™‚çš„è³‡è¨Šä¾†å›ç­”ã€‚å›ç­”å¾Œè«‹æ¨™è¨»ä½ åƒè€ƒäº†ç¶²è·¯è³‡æ–™ã€‚]";
            }

            const payload = {
                contents: historyContents,
                systemInstruction: { parts: [{ text: effectiveSystemPrompt }] }
            };

            if (isSearchEnabled) payload.tools = [{ google_search: {} }];

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`API è«‹æ±‚å¤±æ•— (${response.status}): ${errorData.error?.message || response.statusText}`);
            }

            const data = await response.json();
            let reply = data.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (data.candidates?.[0]?.groundingMetadata?.groundingChunks) {
                reply += "\n\n> ğŸ” *å·²åƒè€ƒæœ€æ–°ç¶²è·¯è³‡æ–™*";
            }

            if (!reply) throw new Error("API å›å‚³æ ¼å¼éŒ¯èª¤æˆ–ç„¡å…§å®¹");

            chatHistory.push({ role: 'user', text: userText });
            chatHistory.push({ role: 'model', text: reply }); 
            
            return reply;
        }

        async function testGeminiConnection(key) {
            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${key}`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: "Hello" }] }] })
                });
                return response.ok;
            } catch (e) { return false; }
        }

        function setEmotion(vrm, emotionName) {
            if (!vrm || !vrm.expressionManager) return;
            resetEmotions(vrm);
            
            const presetMap = {
                'neutral': ['neutral'],
                'joy': ['joy', 'happy'],        
                'angry': ['angry'],             
                'sorrow': ['sorrow', 'sad'],    
                'fun': ['fun', 'relaxed'],      
                'surprised': ['surprised', 'neutral'] 
            };

            const targets = presetMap[emotionName];
            if(targets) {
                let found = false;
                for (let t of targets) {
                     if (vrm.expressionManager.getExpression(t)) {
                         vrm.expressionManager.setValue(t, 1.0);
                         currentEmotion = t;
                         found = true;
                         break;
                     }
                }
                if (!found && emotionName === 'surprised') {
                    vrm.expressionManager.setValue('aa', 0.5);
                    vrm.expressionManager.setValue('neutral', 1.0);
                }
            }
        }

        function resetEmotions(vrm) {
            if (!vrm || !vrm.expressionManager) return;
            const emotions = ['joy', 'happy', 'angry', 'sorrow', 'sad', 'fun', 'relaxed', 'surprised', 'neutral', 'blink', 'blink_l', 'blink_r', 'blinkLeft', 'blinkRight', 'aa', 'ih', 'ou', 'ee', 'oh'];
            emotions.forEach(e => {
                if(vrm.expressionManager.getExpression(e)) vrm.expressionManager.setValue(e, 0);
            });
            currentEmotion = null;
        }

        function speak(text) {
            if (speechSynth.speaking) speechSynth.cancel();
            if (speakingSafetyTimer) clearTimeout(speakingSafetyTimer);

            const cleanText = text.replace(/> ğŸ” \*å·²åƒè€ƒæœ€æ–°ç¶²è·¯è³‡æ–™\*/g, "");
            const utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.lang = 'zh-TW';
            utterance.rate = 1.0;
            utterance.pitch = 1.2;

            utterance.onstart = () => { 
                isSpeaking = true; 
                if (isListening) updateStatus("ğŸ”Š AI èªªè©±ä¸­ (éº¥å…‹é¢¨ä¿æŒé–‹å•Ÿ)...");
                speakingSafetyTimer = setTimeout(() => {
                    console.warn("SpeechSynthesis safety timeout triggered.");
                    stopSpeakingForcefully();
                }, 45000);
            };
            
            utterance.onend = () => { 
                isSpeaking = false; 
                if (speakingSafetyTimer) clearTimeout(speakingSafetyTimer);
                if(currentVrm && currentVrm.expressionManager) {
                     currentVrm.expressionManager.setValue('aa', 0);
                     resetEmotions(currentVrm); 
                     autoBlinkEnabled = true;
                }
                if (isListening) updateStatus("ğŸ‘‚ æ­£åœ¨è†è½...");
                else updateStatus("");
            };
            
            utterance.onerror = () => { 
                isSpeaking = false; 
                if (speakingSafetyTimer) clearTimeout(speakingSafetyTimer);
                resetEmotions(currentVrm);
                autoBlinkEnabled = true;
                if (isListening) updateStatus("ğŸ‘‚ æ­£åœ¨è†è½...");
            };
            
            speechSynth.speak(utterance);
        }

        function addChatMessage(role, text, isLoading = false) {
            const container = document.getElementById('chat-history');
            const div = document.createElement('div');
            const id = 'msg-' + Date.now();
            div.id = id;
            const isUser = role === 'user';
            
            let alignmentClass = 'justify-center'; 
            if (role === 'user') alignmentClass = 'justify-end';
            
            div.className = `flex w-full ${alignmentClass} chat-slide-up`;
            
            let contentHtml = isLoading ? `<span class="animate-pulse">thinking...</span>` : (role === 'system' ? text : marked.parse(text)); 
            
            let bubbleClass = 'bg-gray-700 text-gray-100 rounded-bl-none prose prose-invert prose-sm';
            if (isUser) bubbleClass = 'bg-blue-600 text-white rounded-br-none';
            else if (role === 'system') bubbleClass = 'bg-gray-800 text-gray-400 text-xs py-1 px-3 rounded-full border border-gray-700';

            div.innerHTML = `
                <div class="max-w-[80%] rounded-2xl px-4 py-2 text-sm shadow-md ${bubbleClass}">
                    ${contentHtml}
                </div>
            `;
            container.insertBefore(div, container.firstChild); 
            container.scrollTop = 0;
            return id;
        }

        function enableChat(enabled) {
            const input = document.getElementById('chat-input');
            const btn = document.getElementById('send-btn');
            const micBtn = document.getElementById('mic-btn');
            const searchBtn = document.getElementById('search-toggle-btn');
            
            input.disabled = !enabled;
            btn.disabled = !enabled;
            micBtn.disabled = !enabled;
            searchBtn.disabled = !enabled;
            input.placeholder = enabled ? "è¼¸å…¥è¨Šæ¯..." : "è«‹å…ˆè¨­å®š API Key";
        }

        function loadVRM(url) {
            const loader = new GLTFLoader();
            loader.register((parser) => new VRMLoaderPlugin(parser));
            document.getElementById('status-screen').style.opacity = '1';
            document.getElementById('status-screen').style.visibility = 'visible'; 
            document.getElementById('status-screen').style.pointerEvents = 'auto'; 
            
            document.getElementById('loading-spinner').classList.replace('hidden', 'flex');
            document.getElementById('upload-prompt').classList.add('hidden');
            
            const loadingText = document.getElementById('loading-text');
            if(loadingText) loadingText.textContent = "æ­£åœ¨è®€å– VRM æ¨¡å‹...";

            loader.load(url, async (gltf) => {
                const vrm = gltf.userData.vrm;
                if (currentVrm) {
                    scene.remove(currentVrm.scene);
                    VRMUtils.deepDispose(currentVrm.scene);
                }
                VRMUtils.removeUnnecessaryVertices(gltf.scene);
                vrm.scene.traverse((obj) => obj.frustumCulled = false);
                currentVrm = vrm;
                scene.add(vrm.scene);
                vrm.scene.rotation.y = 0; 
                
                setTimeout(() => {
                    const ss = document.getElementById('status-screen');
                    ss.style.opacity = '0';
                    ss.style.pointerEvents = 'none';
                    setTimeout(() => {
                        ss.style.visibility = 'hidden'; 
                        document.getElementById('loading-spinner').classList.replace('flex', 'hidden');
                        document.getElementById('upload-prompt').classList.remove('hidden');
                    }, 500);
                }, 500);
            }, undefined, (err) => { 
                console.error(err); 
                alert("è¼‰å…¥å¤±æ•—"); 
            });
        }

        function updateLivingAnimation(vrm, deltaTime, elapsedTime) {
            if (!vrm) return;

            if (autoBlinkEnabled) {
                blinkTimer += deltaTime;
                if (blinkTimer > nextBlinkTime) {
                    vrm.expressionManager.setValue('blink', 1.0);
                    if (blinkTimer > nextBlinkTime + 0.15) {
                        vrm.expressionManager.setValue('blink', 0.0);
                        blinkTimer = 0;
                        nextBlinkTime = 2 + Math.random() * 4; 
                    }
                }
            }

            const s = Math.sin(elapsedTime * 1.5); 
            const spine = vrm.humanoid.getNormalizedBoneNode('spine');
            if (spine) {
                spine.rotation.x = s * 0.03; 
                spine.rotation.y = Math.sin(elapsedTime * 0.5) * 0.02; 
            }

            const leftArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
            const rightArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
            
            if (leftArm && rightArm) {
                const armRotationZ = 1.0;
                leftArm.rotation.z = -armRotationZ; 
                rightArm.rotation.z = armRotationZ;
                leftArm.rotation.z -= s * 0.05;
                rightArm.rotation.z += s * 0.05;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.05);
            const elapsedTime = clock.elapsedTime;

            if (currentVrm) {
                currentVrm.update(deltaTime);
                updateLivingAnimation(currentVrm, deltaTime, elapsedTime);

                if (isSpeaking && currentVrm.expressionManager) {
                    const s = Math.sin(elapsedTime * 15); 
                    const openValue = (s + 1) / 2 * 0.7;
                    currentVrm.expressionManager.setValue('aa', openValue);
                }
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>