<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8">
<title>AI VTuber - èª¿æ•´å°è©±æ¡†é«˜åº¦</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f4f8;
        font-family: "Noto Sans TC", sans-serif;
    }
    
    /* è®€å–ç•«é¢ */
    #loading-screen {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 999;
        transition: opacity 0.5s ease;
    }
    
    .loader {
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        width: 50px; height: 50px;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
    }

    .loading-text { color: #555; font-size: 1.2rem; font-weight: bold; }

    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* API ç‹€æ…‹ */
    #api-status {
        position: absolute;
        top: 20px; right: 20px;
        padding: 8px 15px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 20px;
        font-size: 14px;
        font-weight: bold;
        color: #666;
        display: flex; align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        z-index: 100;
    }
    .status-dot { width: 10px; height: 10px; border-radius: 50%; background-color: #ccc; margin-right: 8px; }
    .status-connected { background-color: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
    .status-error { background-color: #e74c3c; box-shadow: 0 0 5px #e74c3c; }

    /* å°è©±ä»‹é¢ (èŠå¤©å®¤é¢¨æ ¼) */
    #chat-container {
        position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
        width: 90%; max-width: 600px;
        display: flex; flex-direction: column; gap: 10px;
        z-index: 100;
    }

    #chat-display {
        background: rgba(0, 0, 0, 0.6);
        padding: 15px; border-radius: 12px;
        height: 120px; /* å›ºå®šé«˜åº¦ (èª¿ä½ä»¥é¿å…é®æ“‹è„–å­) */
        overflow-y: auto; /* è¶…å‡ºå¯æ²å‹• */
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255,255,255,0.2);
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    /* è¨Šæ¯æ³¡æ³¡æ¨£å¼ */
    .message {
        padding: 8px 12px;
        border-radius: 10px;
        max-width: 80%;
        word-wrap: break-word;
        font-size: 15px;
        line-height: 1.4;
        color: white;
    }

    .message-user {
        align-self: flex-end; /* é å³ */
        background-color: #3498db;
        border-bottom-right-radius: 2px;
    }

    .message-ai {
        align-self: flex-start; /* é å·¦ */
        background-color: rgba(255, 255, 255, 0.2);
        border-bottom-left-radius: 2px;
    }

    .message-system {
        align-self: center;
        background: transparent;
        color: #aaa;
        font-size: 12px;
        font-style: italic;
    }

    /* è¶…é€£çµæ¨£å¼ */
    .message a {
        color: #4db8ff; /* äº®è—è‰²ï¼Œåœ¨æ·±è‰²èƒŒæ™¯æ¸…æ¥š */
        text-decoration: underline;
        font-weight: bold;
        transition: color 0.2s;
    }
    .message a:hover {
        color: #80d4ff;
    }
    .message-user a {
        color: #cceeff; /* åœ¨è—è‰²èƒŒæ™¯ä¸Šçš„é€£çµé¡è‰² */
    }

    #input-area { display: flex; gap: 10px; }
    #user-input {
        flex: 1; padding: 12px; border-radius: 25px; border: none; outline: none;
        background: rgba(255, 255, 255, 0.9); font-size: 16px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    #send-btn {
        padding: 0 20px; border-radius: 25px; border: none;
        background: #3498db; color: white; font-weight: bold; cursor: pointer;
        transition: background 0.2s;
    }
    #send-btn:hover { background: #2980b9; }
    #send-btn:disabled { background: #95a5a6; cursor: not-allowed; }

    /* éœéŸ³æŒ‰éˆ•æ¨£å¼ */
    #mute-btn {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        border: none;
        background: rgba(255, 255, 255, 0.9);
        font-size: 20px;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        transition: all 0.2s;
    }
    #mute-btn:hover { background: #fff; transform: scale(1.05); }
    #mute-btn.muted { background: #e74c3c; color: white; }
    
    /* ç•¶å‰è¡¨æƒ…æç¤º (é™¤éŒ¯ç”¨) */
    #emotion-debug {
        position: absolute; top: 70px; right: 20px;
        font-size: 12px; color: #555;
        background: rgba(255,255,255,0.9);
        padding: 8px 12px; border-radius: 8px;
        pointer-events: none;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        text-align: right;
        line-height: 1.4;
    }

</style>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
        "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js"
    }
}
</script>
</head>

<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <div class="loading-text" id="status-text">æ­£åœ¨åˆå§‹åŒ–è¡¨æƒ…ç³»çµ±...</div>
    </div>

    <div id="api-status">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-msg">é€£ç·šä¸­...</span>
    </div>
    
    <div id="emotion-debug">
        æƒ…ç·’: Neutral<br>
        å‹•ä½œ: None
    </div>

    <div id="chat-container">
        <div id="chat-display">
            <!-- åˆå§‹æ­¡è¿è¨Šæ¯ (ä¸­è‹±å°ç…§) -->
            <div class="message message-ai">
                Hello! I am your AI partner. You can speak English or Chinese. Try "Close right eye" or tell me something sad!<br><br>
                ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„ AI å¤¥ä¼´ã€‚ä½ å¯ä»¥èªªä¸­æ–‡æˆ–è‹±æ–‡ã€‚è©¦è©¦çœ‹å«æˆ‘ã€Œé–‰ä¸Šå³çœ¼ã€æˆ–å‘Šè¨´æˆ‘ä¸€äº›ã€Œæ‚²å‚·ã€çš„äº‹ï¼
            </div>
        </div>
        <div id="input-area">
            <button id="mute-btn" title="åˆ‡æ›è²éŸ³">ğŸ”Š</button>
            <input type="text" id="user-input" placeholder="Try: Search for latest news" disabled>
            <button id="send-btn" disabled>Send</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        const GEMINI_API_KEY = "AIzaSyAQckQ8clyCDVDnyBKd5TMvVMm7oFsmTgY";
        const GEMINI_MODEL = "gemini-2.0-flash-exp"; 
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
        const VRM_URL = 'https://davidkuodcam-crypto.github.io/VTuber/AvatarSample_C.vrm';

        let currentVrm = undefined;
        let chatHistory = [];
        let isSpeaking = false;
        let currentEmotion = 'neutral';
        let isMuted = false; // éœéŸ³ç‹€æ…‹
        
        // --- 1. å ´æ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f4f8);
        scene.add(new THREE.GridHelper(10, 10, 0x888888, 0xe0e0e0));

        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        camera.position.set(0.0, 1.4, 3.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(1.0, 1.0, 1.0).normalize();
        scene.add(directionalLight);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0.0, 1.0, 0.0);
        controls.enableDamping = true;
        controls.update();

        // --- 2. è¼‰å…¥ VRM ---
        const loader = new GLTFLoader();
        loader.crossOrigin = 'anonymous';
        loader.register((parser) => new VRMLoaderPlugin(parser));

        loader.load(
            VRM_URL,
            (gltf) => {
                const vrm = gltf.userData.vrm;
                VRMUtils.rotateVRM0(vrm);
                scene.add(vrm.scene);
                currentVrm = vrm;
                
                // A-Pose ä¿®æ­£
                const leftUpperArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                const rightUpperArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
                if (leftUpperArm) { leftUpperArm.rotation.z = -1.1; leftUpperArm.rotation.x = 0.15; }
                if (rightUpperArm) { rightUpperArm.rotation.z = 1.1; rightUpperArm.rotation.x = 0.15; }

                // èª¿æ•´ç›¸æ©Ÿç‰¹å¯«
                const headNode = vrm.humanoid.getNormalizedBoneNode('head');
                if (headNode) {
                    const headPos = new THREE.Vector3();
                    headNode.getWorldPosition(headPos);
                    controls.target.set(headPos.x, headPos.y, headPos.z);
                    camera.position.set(headPos.x, headPos.y, headPos.z + 1.0);
                    controls.update();
                }

                document.getElementById('loading-screen').style.display = 'none';
                
                // å•Ÿå‹•çœ¨çœ¼
                startBlinking();
                testApiConnection();
            },
            (progress) => {
                const percent = Math.round(100.0 * (progress.loaded / progress.total));
                document.getElementById('status-text').innerText = `æ­£åœ¨ä¸‹è¼‰æ¨¡å‹... ${percent}%`;
            },
            (error) => console.error(error)
        );

        // --- 3. å‹•ç•«èˆ‡ç‰©ç† ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.elapsedTime;

            if (currentVrm) {
                currentVrm.update(deltaTime);

                // å‘¼å¸æ“ºå‹•
                const spine = currentVrm.humanoid.getNormalizedBoneNode('spine');
                if (spine) {
                    spine.rotation.x = Math.sin(elapsedTime * 1.5) * 0.03;
                    spine.rotation.y = Math.sin(elapsedTime * 0.8) * 0.02;
                }

                // å˜´å‹åŒæ­¥
                if (isSpeaking && !isMuted) {
                    const s = Math.sin(elapsedTime * 15);
                    currentVrm.expressionManager.setValue('aa', (s + 1) / 2 * 0.7);
                } else {
                    const currentVal = currentVrm.expressionManager.getValue('aa');
                    currentVrm.expressionManager.setValue('aa', THREE.MathUtils.lerp(currentVal, 0, 0.2));
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // çœ¨çœ¼ç³»çµ±
        function startBlinking() {
            if(!currentVrm) return;
            const blinkLoop = () => {
                if (!window.actionActive) {
                    const blinkDuration = Math.random() * 3 + 2; 
                    setTimeout(() => {
                        currentVrm.expressionManager.setValue('blink', 1);
                        setTimeout(() => {
                            currentVrm.expressionManager.setValue('blink', 0);
                            blinkLoop();
                        }, 150);
                    }, blinkDuration * 1000);
                } else {
                    setTimeout(blinkLoop, 1000);
                }
            };
            blinkLoop();
        }

        // --- 4. è¡¨æƒ…æ§åˆ¶æ ¸å¿ƒ ---

        const VALID_EMOTIONS = ['neutral', 'happy', 'angry', 'sad', 'relaxed', 'surprised'];
        
        function setEmotion(emotionName) {
            if (!currentVrm || !emotionName) return;
            
            // å®¹éŒ¯æ˜ å°„
            if (emotionName === 'joy') emotionName = 'happy';
            if (emotionName === 'sorrow') emotionName = 'sad';
            if (emotionName === 'fun') emotionName = 'relaxed';
            
            if (!VALID_EMOTIONS.includes(emotionName)) emotionName = 'neutral';

            console.log("Setting Emotion:", emotionName);
            currentEmotion = emotionName;

            updateDebugDisplay(emotionName, null);

            // é‡ç½®æ‰€æœ‰æƒ…ç·’
            VALID_EMOTIONS.forEach(emo => {
                currentVrm.expressionManager.setValue(emo, 0);
            });

            // è¨­å®šç›®æ¨™æƒ…ç·’
            if (emotionName !== 'neutral') {
                currentVrm.expressionManager.setValue(emotionName, 0.8);
            }
        }

        window.actionActive = false; 

        function triggerAction(actionName, duration) {
            if (!currentVrm || actionName === 'none' || !duration) {
                updateDebugDisplay(null, 'None');
                return;
            }

            console.log(`Trigger Action: ${actionName} for ${duration}ms`);
            updateDebugDisplay(null, `${actionName} (${duration}ms)`);
            
            let shapeName = null;
            if (actionName === 'blink_left') shapeName = 'blinkLeft';
            if (actionName === 'blink_right') shapeName = 'blinkRight';
            if (actionName === 'blink_both') shapeName = 'blink';

            if (shapeName) {
                window.actionActive = true;
                currentVrm.expressionManager.setValue(shapeName, 1.0); // å®Œå…¨é–‰åˆ

                // è¨­å®šå®šæ™‚å™¨æ¢å¾©
                setTimeout(() => {
                    currentVrm.expressionManager.setValue(shapeName, 0);
                    window.actionActive = false;
                    updateDebugDisplay(null, 'Done');
                }, duration);
            }
        }

        function updateDebugDisplay(emo, act) {
            const debugDiv = document.getElementById('emotion-debug');
            if(emo) debugDiv.innerHTML = debugDiv.innerHTML.replace(/æƒ…ç·’: .*/, `æƒ…ç·’: ${emo}`);
            if(act) debugDiv.innerHTML = debugDiv.innerHTML.replace(/å‹•ä½œ: .*/, `å‹•ä½œ: ${act}`);
        }

        // --- 5. èŠå¤©å®¤ UI è¼”åŠ©å‡½å¼ (å« Markdown è§£æ) ---
        
        function formatText(text) {
            let safeText = text.replace(/&/g, "&amp;")
                               .replace(/</g, "&lt;")
                               .replace(/>/g, "&gt;")
                               .replace(/"/g, "&quot;")
                               .replace(/'/g, "&#039;");

            safeText = safeText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, linkText, url) => {
                return `<a href="${url}" target="_blank" rel="noopener noreferrer">${linkText}</a>`;
            });

            safeText = safeText.replace(/\n/g, "<br>");
            return safeText;
        }

        function addMessage(text, type) {
            const chatDisplay = document.getElementById('chat-display');
            const div = document.createElement('div');
            div.className = `message message-${type}`;
            div.innerHTML = formatText(text);
            chatDisplay.appendChild(div);
            chatDisplay.scrollTop = chatDisplay.scrollHeight;
            return div;
        }

        function removeMessage(element) {
            if(element && element.parentNode) {
                element.parentNode.removeChild(element);
            }
        }

        // --- 6. Gemini API ---
        
        const statusDot = document.getElementById('status-dot');
        const statusMsg = document.getElementById('status-msg');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const muteBtn = document.getElementById('mute-btn');
        const chatDisplay = document.getElementById('chat-display');

        // é å…ˆè¼‰å…¥èªéŸ³
        let availableVoices = [];
        window.speechSynthesis.onvoiceschanged = () => {
            availableVoices = window.speechSynthesis.getVoices();
            console.log("Voices loaded:", availableVoices.length);
        };

        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            if (isMuted) {
                muteBtn.innerText = 'ğŸ”‡';
                muteBtn.classList.add('muted');
                window.speechSynthesis.cancel(); 
                isSpeaking = false; 
                if(currentVrm) currentVrm.expressionManager.setValue('aa', 0); 
            } else {
                muteBtn.innerText = 'ğŸ”Š';
                muteBtn.classList.remove('muted');
            }
        });

        async function testApiConnection() {
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: "Hello" }] }] })
                });
                if (response.ok) {
                    statusDot.classList.add('status-connected');
                    statusMsg.innerText = "é›™èªç³»çµ±å°±ç·’";
                    enableChat();
                } else throw new Error();
            } catch (e) {
                statusDot.classList.add('status-error');
                statusMsg.innerText = "é€£ç·šå¤±æ•—";
            }
        }

        function enableChat() {
            userInput.disabled = false; sendBtn.disabled = false; userInput.focus();
        }

        async function handleSendMessage() {
            const text = userInput.value.trim();
            if (!text) return;

            userInput.value = ''; 
            userInput.disabled = true; 
            sendBtn.disabled = true;
            
            addMessage(text, 'user');
            const loadingMsg = addMessage("Thinking...", 'system');
            chatHistory.push({ role: "user", parts: [{ text: text }] });

            const systemPrompt = `
                You are a virtual AI character.
                
                ã€Language Rules - STRICTã€‘
                1. Default Language: Traditional Chinese (zh-TW). 
                2. Forbidden: Do NOT use Simplified Chinese (zh-CN).
                3. Bilingual: If user speaks English, reply in English. 
                4. Other Languages: If user requests a specific language (e.g., Japanese, French), you must comply.
                
                ã€Search & Link Rules - CRITICALã€‘
                Use Google Search for ANY query about news, weather, time, or facts.
                **DIRECTLY** provide the answer derived from search results.
                **IMPORTANT:** When providing sources or links, use Markdown format: [Link Title](URL).
                **DO NOT** say "I will search", "Let me check", or "Searching now". Just give the answer.
                **UNKNOWN INFO:** If you cannot find the answer or don't know, simply say "ä¸çŸ¥é“" (or "I don't know" in English).

                ã€Emotion & Action Logicã€‘
                Supported Emotions: neutral, happy, angry, sad, relaxed, surprised.
                Supported Actions: blink_left, blink_right, blink_both.
                
                **UNKNOWN EXPRESSIONS:** If user requests an expression/action NOT supported (e.g. "roll eyes", "tongue out"), say "æˆ‘ä¸æœƒ" (or "I can't do that" in English).

                Emotion Logic (Synonyms):
                1. Commands: "Angry" -> emotion="angry". "Close right eye" -> action="blink_right".
                2. Content Emotion: 
                   - Sad/Sorrow/Grief (æ‚²å‚·/å“€å‚·/é›£é/ç—›è‹¦) -> emotion="sad"
                   - Happy/Joy/Excited (é–‹å¿ƒ/å¿«æ¨‚/é«˜èˆˆ) -> emotion="happy"
                   - Surprised/Shocked (é©šè¨/åš‡) -> emotion="surprised"
                   - Angry/Mad (ç”Ÿæ°£/æ†¤æ€’/ç«å¤§) -> emotion="angry"

                Output strictly JSON:
                {
                    "text": "Your response text (include Markdown links for sources)",
                    "emotion": "neutral" | "happy" | "angry" | "sad" | "relaxed" | "surprised",
                    "action": "none" | "blink_left" | "blink_right" | "blink_both",
                    "duration": 0
                }
            `;

            try {
                const safeHistory = chatHistory.filter(msg => {
                    const part = msg.parts[0];
                    return part && typeof part.text === 'string' && part.text.trim() !== '' && part.text !== '...';
                });

                const payload = {
                    contents: safeHistory,
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    tools: [{ google_search: {} }],
                };

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();
                if (data.error) throw new Error(data.error.message);

                removeMessage(loadingMsg);

                let rawText = data.candidates[0].content.parts[0].text;
                let result = { text: "", emotion: 'neutral', action: 'none', duration: 0 };

                try {
                    const jsonMatch = rawText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        result = JSON.parse(jsonMatch[0]);
                    } else {
                        result.text = rawText;
                        result.emotion = 'neutral';
                    }
                } catch (e) {
                    console.warn("JSON Parse Failed", e);
                    result.text = rawText;
                }

                if (!result.text) result.text = result.response || result.message || rawText;

                const lowerText = result.text.toLowerCase();
                const inputLower = text.toLowerCase();

                if (inputLower.match(/(é–‰|çœ¨|close|blink).*(å³|right)/)) {
                    result.action = "blink_right";
                    result.duration = 3000;
                } else if (inputLower.match(/(é–‰|çœ¨|close|blink).*(å·¦|left)/)) {
                    result.action = "blink_left";
                    result.duration = 3000;
                }

                if (!result.emotion || result.emotion === 'neutral') {
                    if (lowerText.match(/(å“€å‚·|æ‚²å‚·|é›£é|ç—›è‹¦|é›£å—|å“­|éºæ†¾|æ…˜|å—š|sad|sorry|regret|cry|grief|sorrow)/)) {
                        result.emotion = 'sad';
                    } 
                    else if (lowerText.match(/(é–‹å¿ƒ|å¿«æ¨‚|é«˜èˆˆ|å–œæ‚…|èˆˆå¥®|æ£’|è®š|å“ˆå“ˆ|å˜»å˜»|happy|glad|great|haha|joy|excited)/)) {
                        result.emotion = 'happy';
                    } 
                    else if (lowerText.match(/(ç”Ÿæ°£|æ†¤æ€’|ç«å¤§|æ°£æ­»|ä¸çˆ½|æƒ±ç«|angry|mad|furious|annoyed)/)) {
                        result.emotion = 'angry';
                    } 
                    else if (lowerText.match(/(é©šè¨|åš‡|é©š|å‚»çœ¼|surprised|shock|wow|amazed)/)) {
                        result.emotion = 'surprised';
                    }
                }

                const finalResponseText = result.text && result.text.length > 0 ? result.text : "ï¼ˆNodï¼‰";

                console.log("Final Result:", result);

                chatHistory.push({ role: "model", parts: [{ text: finalResponseText }] });
                
                addMessage(finalResponseText, 'ai');
                
                setEmotion(result.emotion || 'neutral');

                if (result.action && result.action !== 'none') {
                    triggerAction(result.action, result.duration || 2000);
                }

                speak(finalResponseText);

            } catch (error) {
                console.error("Error:", error);
                removeMessage(loadingMsg);
                addMessage("System Busy...", 'system');
            } finally {
                userInput.disabled = false; sendBtn.disabled = false; userInput.focus();
            }
        }

        // å‡ç´šç‰ˆèªéŸ³ï¼šåš´æ ¼ä¸­è‹±ç™¼è²ï¼ˆWhitelist Logicï¼‰
        function speak(text) {
            if (isMuted) return;

            // 1. éæ¿¾ Markdown é€£çµ (ç§»é™¤é€£çµæ–‡å­—èˆ‡ç¶²å€)
            const cleanText = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '');

            // 2. æº–å‚™åˆ¤æ–·è®Šæ•¸
            // ç§»é™¤æ‰€æœ‰ ASCII ç¯„åœå…§çš„å­—å…ƒ (\x00-\x7F)ï¼Œä»¥åŠå¸¸è¦‹å…¨å½¢æ¨™é»
            const textWithoutASCII = cleanText.replace(/[\x00-\x7F]/g, '');
            const textWithoutSymbols = textWithoutASCII.replace(/[\u3000-\u303F\uFF00-\uFFEF\u2000-\u206F]/g, '');
            
            // æª¢æŸ¥æ˜¯å¦æœ‰ä¸­æ–‡
            const hasChinese = /[\u4e00-\u9fa5]/.test(cleanText);

            let targetLang = '';

            // 3. é‚è¼¯åˆ¤æ–· (æ­£å‘è¡¨åˆ—)
            if (hasChinese) {
                // æœ‰ä¸­æ–‡ -> è¬›ä¸­æ–‡
                targetLang = 'zh-TW';
            } else {
                // æ²’ä¸­æ–‡ -> æª¢æŸ¥æ˜¯å¦å‰©ä¸‹å…¶ä»–å¤–èªå­—å…ƒ
                // å¦‚æœç§»é™¤ ASCII å’Œæ¨™é»å¾Œï¼Œå­—ä¸²é•·åº¦ç‚º 0ï¼Œä»£è¡¨åªå‰©ä¸‹è‹±æ–‡/æ•¸å­—/ç¬¦è™Ÿ -> è¬›è‹±æ–‡
                // å¦‚æœå­—ä¸²é•·åº¦ > 0ï¼Œä»£è¡¨æœ‰æ—¥æ–‡å‡åã€éŸ“æ–‡ã€ä¿„æ–‡ç­‰ -> éœéŸ³
                if (textWithoutSymbols.trim().length === 0) {
                    targetLang = 'en-US';
                } else {
                    console.log("åµæ¸¬åˆ°éä¸­è‹±æ–‡å…§å®¹ï¼ŒéœéŸ³");
                    return; // éœéŸ³
                }
            }

            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(cleanText);
            
            utterance.lang = targetLang;
            utterance.rate = 1.0; 
            utterance.pitch = 0.8; 

            if (availableVoices.length === 0) {
                availableVoices = window.speechSynthesis.getVoices();
            }
            
            // å˜—è©¦å°‹æ‰¾ Google èªéŸ³ä»¥ç²å¾—è¼ƒå¥½çš„ä¸€è‡´æ€§
            let voiceTarget = targetLang === 'zh-TW' ? 'zh' : 'en';
            let voice = availableVoices.find(v => v.lang.includes(voiceTarget) && v.name.includes('Google'));
            
            if (!voice) {
                voice = availableVoices.find(v => v.lang.includes(voiceTarget));
            }
            
            if (voice) utterance.voice = voice;

            utterance.onstart = () => { isSpeaking = true; };
            utterance.onend = () => { isSpeaking = false; if(currentVrm) currentVrm.expressionManager.setValue('aa', 0); };
            window.speechSynthesis.speak(utterance);
        }

        sendBtn.addEventListener('click', handleSendMessage);
        userInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleSendMessage(); });

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                window.speechSynthesis.cancel();
                isSpeaking = false;
                if (currentVrm) currentVrm.expressionManager.setValue('aa', 0);
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
