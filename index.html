<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8">
<title>AI VTuber - å‹•æ…‹çŸ¥è­˜åº«ç‰ˆ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f4f8;
        font-family: "Noto Sans TC", sans-serif;
    }
    
    /* è®€å–ç•«é¢ */
    #loading-screen {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 999;
        transition: opacity 0.5s ease;
    }
    
    .loader {
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        width: 50px; height: 50px;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
    }

    .loading-text { color: #555; font-size: 1.2rem; font-weight: bold; }

    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* API ç‹€æ…‹ */
    #api-status {
        position: absolute;
        top: 20px; right: 20px;
        padding: 8px 15px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 20px;
        font-size: 14px;
        font-weight: bold;
        color: #666;
        display: flex; align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        z-index: 100;
    }
    .status-dot { width: 10px; height: 10px; border-radius: 50%; background-color: #ccc; margin-right: 8px; }
    .status-connected { background-color: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
    .status-error { background-color: #e74c3c; box-shadow: 0 0 5px #e74c3c; }

    /* æª”æ¡ˆè®€å–ç‹€æ…‹é¢æ¿ (æ–°å¢) */
    #file-status {
        position: absolute;
        top: 20px; left: 20px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        font-size: 13px;
        color: #333;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 100;
        max-width: 220px;
        transition: opacity 0.5s;
        pointer-events: none; /* è®“æ»‘é¼ å¯ä»¥ç©¿é€é»æ“Šå¾Œé¢çš„ 3D */
    }
    .file-status-item { 
        margin-bottom: 6px; 
        display: flex; 
        align-items: center; 
        white-space: nowrap;
    }
    .file-status-item:last-child { margin-bottom: 0; }
    .icon-ok { color: #27ae60; margin-right: 8px; font-weight: bold; font-size: 14px; }
    .icon-fail { color: #e74c3c; margin-right: 8px; font-weight: bold; font-size: 14px; }
    .icon-loading { color: #3498db; margin-right: 8px; font-weight: bold; animation: pulse 1s infinite; }
    
    @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

    /* å°è©±ä»‹é¢ (èŠå¤©å®¤é¢¨æ ¼) */
    #chat-container {
        position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
        width: 90%; max-width: 600px;
        display: flex; flex-direction: column; gap: 10px;
        z-index: 100;
    }

    #chat-display {
        background: rgba(0, 0, 0, 0.6);
        padding: 15px; border-radius: 12px;
        height: 120px; /* å›ºå®šé«˜åº¦ */
        overflow-y: auto; /* è¶…å‡ºå¯æ²å‹• */
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255,255,255,0.2);
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    /* è¨Šæ¯æ³¡æ³¡æ¨£å¼ */
    .message {
        padding: 8px 12px;
        border-radius: 10px;
        max-width: 80%;
        word-wrap: break-word;
        font-size: 15px;
        line-height: 1.4;
        color: white;
    }

    .message-user {
        align-self: flex-end; /* é å³ */
        background-color: #3498db;
        border-bottom-right-radius: 2px;
    }

    .message-ai {
        align-self: flex-start; /* é å·¦ */
        background-color: rgba(255, 255, 255, 0.2);
        border-bottom-left-radius: 2px;
    }

    .message-system {
        align-self: center;
        background: transparent;
        color: #aaa;
        font-size: 12px;
        font-style: italic;
    }

    /* è¶…é€£çµæ¨£å¼ */
    .message a {
        color: #4db8ff; /* äº®è—è‰²ï¼Œåœ¨æ·±è‰²èƒŒæ™¯æ¸…æ¥š */
        text-decoration: underline;
        font-weight: bold;
        transition: color 0.2s;
    }
    .message a:hover {
        color: #80d4ff;
    }
    .message-user a {
        color: #cceeff; /* åœ¨è—è‰²èƒŒæ™¯ä¸Šçš„é€£çµé¡è‰² */
    }

    #input-area { display: flex; gap: 10px; }
    #user-input {
        flex: 1; padding: 12px; border-radius: 25px; border: none; outline: none;
        background: rgba(255, 255, 255, 0.9); font-size: 16px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    #send-btn {
        padding: 0 20px; border-radius: 25px; border: none;
        background: #3498db; color: white; font-weight: bold; cursor: pointer;
        transition: background 0.2s;
    }
    #send-btn:hover { background: #2980b9; }
    #send-btn:disabled { background: #95a5a6; cursor: not-allowed; }

    /* éœéŸ³æŒ‰éˆ•æ¨£å¼ */
    #mute-btn {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        border: none;
        background: rgba(255, 255, 255, 0.9);
        font-size: 20px;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        transition: all 0.2s;
    }
    #mute-btn:hover { background: #fff; transform: scale(1.05); }
    #mute-btn.muted { background: #e74c3c; color: white; }
    
    /* ç•¶å‰è¡¨æƒ…æç¤º (é™¤éŒ¯ç”¨) */
    #emotion-debug {
        position: absolute; top: 70px; right: 20px;
        font-size: 12px; color: #555;
        background: rgba(255,255,255,0.9);
        padding: 8px 12px; border-radius: 8px;
        pointer-events: none;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        text-align: right;
        line-height: 1.4;
    }

</style>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
        "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js"
    }
}
</script>
</head>

<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <div class="loading-text" id="status-text">åˆå§‹åŒ–ç³»çµ±ä¸­...</div>
    </div>

    <!-- æ–°å¢ï¼šæª”æ¡ˆè®€å–ç‹€æ…‹é¢æ¿ -->
    <div id="file-status">
        <div class="file-status-item"><span class="icon-loading">â—</span> æº–å‚™è®€å–æª”æ¡ˆ...</div>
    </div>

    <div id="api-status">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-msg">é€£ç·šä¸­...</span>
    </div>
    
    <div id="emotion-debug">
        æƒ…ç·’: Neutral<br>
        å‹•ä½œ: None
    </div>

    <div id="chat-container">
        <div id="chat-display">
            <!-- åˆå§‹æ­¡è¿è¨Šæ¯ (ä¸­è‹±å°ç…§) -->
            <div class="message message-ai">
                Hello! I am your AI partner. You can speak English or Chinese.<br><br>
                ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„ AI å¤¥ä¼´ã€‚ä½ å¯ä»¥èªªä¸­æ–‡æˆ–è‹±æ–‡ã€‚è©¦è©¦çœ‹å•æˆ‘çŸ¥è­˜åº«è£¡çš„å…§å®¹ï¼
            </div>
        </div>
        <div id="input-area">
            <button id="mute-btn" title="åˆ‡æ›è²éŸ³">ğŸ”Š</button>
            <input type="text" id="user-input" placeholder="è¼¸å…¥è¨Šæ¯..." disabled>
            <button id="send-btn" disabled>Send</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        const GEMINI_API_KEY = "AIzaSyAQckQ8clyCDVDnyBKd5TMvVMm7oFsmTgY";
        const GEMINI_MODEL = "gemini-2.0-flash-exp"; 
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
        const VRM_URL = 'https://davidkuodcam-crypto.github.io/VTuber/AvatarSample_C.vrm';

        let currentVrm = undefined;
        let chatHistory = [];
        let isSpeaking = false;
        let currentEmotion = 'neutral';
        let isMuted = false;
        
        // --- å…¨åŸŸè®Šæ•¸ï¼šå„²å­˜å¤–éƒ¨çŸ¥è­˜ ---
        let externalSystemPrompt = ""; 
        let externalKnowledge = "";

        // --- 1. å ´æ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f4f8);
        scene.add(new THREE.GridHelper(10, 10, 0x888888, 0xe0e0e0));

        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        camera.position.set(0.0, 1.4, 3.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(1.0, 1.0, 1.0).normalize();
        scene.add(directionalLight);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0.0, 1.0, 0.0);
        controls.enableDamping = true;
        controls.update();

        // --- 2. å¤–éƒ¨æª”æ¡ˆè®€å– (æ ¸å¿ƒæ–°åŠŸèƒ½ï¼šå«ç‹€æ…‹é¡¯ç¤º) ---
        async function loadExternalData() {
            const statusText = document.getElementById('status-text');
            const fileStatusDiv = document.getElementById('file-status');
            
            // åˆå§‹åŒ–ç‹€æ…‹æ–‡å­—è®Šæ•¸
            let promptStatusHTML = '<span class="icon-loading">â—</span> è®€å– Prompt.txt...';
            let kbStatusHTML = '<span class="icon-loading">â—</span> è®€å–çŸ¥è­˜åº«...';

            // æ›´æ–° UI çš„è¼”åŠ©å‡½å¼
            const renderStatus = () => {
                fileStatusDiv.innerHTML = `
                    <div class="file-status-item">${promptStatusHTML}</div>
                    <div class="file-status-item">${kbStatusHTML}</div>
                `;
            };
            
            renderStatus(); // åˆå§‹é¡¯ç¤º

            // 2.1 è®€å– Prompt.txt
            try {
                statusText.innerText = "è®€å–è§’è‰²è¨­å®š...";
                const res = await fetch(`./Prompt.txt?t=${Date.now()}`);
                if (res.ok) {
                    externalSystemPrompt = await res.text();
                    console.log("Loaded Prompt.txt");
                    promptStatusHTML = '<span class="icon-ok">âœ“</span> Prompt.txt (OK)';
                } else {
                    console.warn("Prompt.txt not found, utilizing built-in default.");
                    promptStatusHTML = '<span class="icon-fail">âœ—</span> Prompt.txt (é è¨­)';
                }
            } catch (e) {
                console.warn("Error loading Prompt.txt", e);
                promptStatusHTML = '<span class="icon-fail">âœ—</span> Prompt.txt (éŒ¯èª¤)';
            }
            renderStatus();

            // 2.2 å¾ªç’°è®€å– KnowledgeBaseXX.txt
            statusText.innerText = "è®€å–é›²ç«¯çŸ¥è­˜åº«...";
            let fileIndex = 1;
            let keepLoading = true;
            let loadedCount = 0;
            
            while (keepLoading) {
                const fileName = `KnowledgeBase${String(fileIndex).padStart(2, '0')}.txt`;
                // æ›´æ–° loading ç‹€æ…‹ï¼Œé¡¯ç¤ºæ­£åœ¨è®€å–å“ªå€‹æª”æ¡ˆ
                kbStatusHTML = `<span class="icon-loading">â—</span> æƒæ ${fileName}...`;
                renderStatus();

                try {
                    const res = await fetch(`./${fileName}?t=${Date.now()}`);
                    if (res.ok) {
                        const text = await res.text();
                        if (text.trim().length > 0) {
                            externalKnowledge += `\n\nã€å¤–éƒ¨çŸ¥è­˜ä¾†æº ${fileName}ã€‘\n${text}`;
                            console.log(`Loaded ${fileName}`);
                            loadedCount++;
                            fileIndex++;
                        } else {
                            // æª”æ¡ˆå­˜åœ¨ä½†ç©ºç™½
                            fileIndex++;
                        }
                    } else {
                        // 404 æˆ–å…¶ä»–éŒ¯èª¤ï¼Œåœæ­¢è®€å–
                        console.log(`Stop loading knowledge at ${fileName}`);
                        keepLoading = false;
                    }
                } catch (e) {
                    keepLoading = false;
                }
            }

            // æœ€çµ‚çŸ¥è­˜åº«ç‹€æ…‹
            if (loadedCount > 0) {
                kbStatusHTML = `<span class="icon-ok">âœ“</span> çŸ¥è­˜åº« (å…± ${loadedCount} æª”)`;
            } else {
                kbStatusHTML = `<span class="icon-fail">âœ—</span> çŸ¥è­˜åº« (æœªè¼‰å…¥)`;
            }
            renderStatus();
            
            statusText.innerText = "ç³»çµ±å°±ç·’ï¼";
        }

        // --- 3. è¼‰å…¥ VRM èˆ‡ å•Ÿå‹•æµç¨‹ ---
        const loader = new GLTFLoader();
        loader.crossOrigin = 'anonymous';
        loader.register((parser) => new VRMLoaderPlugin(parser));

        // åŒæ™‚åŸ·è¡Œæ¨¡å‹ä¸‹è¼‰èˆ‡æ–‡å­—æª”è®€å–
        Promise.all([
            new Promise((resolve) => {
                loader.load(
                    VRM_URL,
                    (gltf) => {
                        const vrm = gltf.userData.vrm;
                        VRMUtils.rotateVRM0(vrm);
                        scene.add(vrm.scene);
                        currentVrm = vrm;
                        
                        // A-Pose ä¿®æ­£
                        const leftUpperArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                        const rightUpperArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
                        if (leftUpperArm) { leftUpperArm.rotation.z = -1.1; leftUpperArm.rotation.x = 0.15; }
                        if (rightUpperArm) { rightUpperArm.rotation.z = 1.1; rightUpperArm.rotation.x = 0.15; }

                        // èª¿æ•´ç›¸æ©Ÿç‰¹å¯«
                        const headNode = vrm.humanoid.getNormalizedBoneNode('head');
                        if (headNode) {
                            const headPos = new THREE.Vector3();
                            headNode.getWorldPosition(headPos);
                            controls.target.set(headPos.x, headPos.y, headPos.z);
                            camera.position.set(headPos.x, headPos.y, headPos.z + 1.0);
                            controls.update();
                        }
                        
                        // å•Ÿå‹•çœ¨çœ¼
                        startBlinking();
                        resolve();
                    },
                    (progress) => {
                        const percent = Math.round(100.0 * (progress.loaded / progress.total));
                        document.getElementById('status-text').innerText = `æ­£åœ¨ä¸‹è¼‰æ¨¡å‹... ${percent}%`;
                    },
                    (error) => {
                        console.error(error);
                        resolve(); // å³ä½¿å¤±æ•—ä¹Ÿç¹¼çºŒï¼Œä»¥å…å¡ä½
                    }
                );
            }),
            loadExternalData() // å‘¼å«æ–‡å­—æª”è®€å–
        ]).then(() => {
            // å…¨éƒ¨å®Œæˆå¾Œé—œé–‰è®€å–ç•«é¢
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                testApiConnection();
            }, 500);
        });

        // --- 4. å‹•ç•«èˆ‡ç‰©ç† ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.elapsedTime;

            if (currentVrm) {
                currentVrm.update(deltaTime);

                // å‘¼å¸æ“ºå‹•
                const spine = currentVrm.humanoid.getNormalizedBoneNode('spine');
                if (spine) {
                    spine.rotation.x = Math.sin(elapsedTime * 1.5) * 0.03;
                    spine.rotation.y = Math.sin(elapsedTime * 0.8) * 0.02;
                }

                // å˜´å‹åŒæ­¥
                if (isSpeaking && !isMuted) {
                    const s = Math.sin(elapsedTime * 15);
                    currentVrm.expressionManager.setValue('aa', (s + 1) / 2 * 0.7);
                } else {
                    const currentVal = currentVrm.expressionManager.getValue('aa');
                    currentVrm.expressionManager.setValue('aa', THREE.MathUtils.lerp(currentVal, 0, 0.2));
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // çœ¨çœ¼ç³»çµ±
        function startBlinking() {
            if(!currentVrm) return;
            const blinkLoop = () => {
                if (!window.actionActive) {
                    const blinkDuration = Math.random() * 3 + 2; 
                    setTimeout(() => {
                        currentVrm.expressionManager.setValue('blink', 1);
                        setTimeout(() => {
                            currentVrm.expressionManager.setValue('blink', 0);
                            blinkLoop();
                        }, 150);
                    }, blinkDuration * 1000);
                } else {
                    setTimeout(blinkLoop, 1000);
                }
            };
            blinkLoop();
        }

        // --- 5. è¡¨æƒ…æ§åˆ¶æ ¸å¿ƒ ---
        const VALID_EMOTIONS = ['neutral', 'happy', 'angry', 'sad', 'relaxed', 'surprised'];
        
        function setEmotion(emotionName) {
            if (!currentVrm || !emotionName) return;
            
            // å®¹éŒ¯æ˜ å°„
            if (emotionName === 'joy') emotionName = 'happy';
            if (emotionName === 'sorrow') emotionName = 'sad';
            if (emotionName === 'fun') emotionName = 'relaxed';
            
            if (!VALID_EMOTIONS.includes(emotionName)) emotionName = 'neutral';

            console.log("Setting Emotion:", emotionName);
            currentEmotion = emotionName;

            updateDebugDisplay(emotionName, null);

            // é‡ç½®æ‰€æœ‰æƒ…ç·’
            VALID_EMOTIONS.forEach(emo => {
                currentVrm.expressionManager.setValue(emo, 0);
            });

            // è¨­å®šç›®æ¨™æƒ…ç·’
            if (emotionName !== 'neutral') {
                currentVrm.expressionManager.setValue(emotionName, 0.8);
            }
        }

        window.actionActive = false; 

        function triggerAction(actionName, duration) {
            if (!currentVrm || actionName === 'none' || !duration) {
                updateDebugDisplay(null, 'None');
                return;
            }

            console.log(`Trigger Action: ${actionName} for ${duration}ms`);
            updateDebugDisplay(null, `${actionName} (${duration}ms)`);
            
            let shapeName = null;
            if (actionName === 'blink_left') shapeName = 'blinkLeft';
            if (actionName === 'blink_right') shapeName = 'blinkRight';
            if (actionName === 'blink_both') shapeName = 'blink';

            if (shapeName) {
                window.actionActive = true;
                currentVrm.expressionManager.setValue(shapeName, 1.0); // å®Œå…¨é–‰åˆ

                // è¨­å®šå®šæ™‚å™¨æ¢å¾©
                setTimeout(() => {
                    currentVrm.expressionManager.setValue(shapeName, 0);
                    window.actionActive = false;
                    updateDebugDisplay(null, 'Done');
                }, duration);
            }
        }

        function updateDebugDisplay(emo, act) {
            const debugDiv = document.getElementById('emotion-debug');
            if(emo) debugDiv.innerHTML = debugDiv.innerHTML.replace(/æƒ…ç·’: .*/, `æƒ…ç·’: ${emo}`);
            if(act) debugDiv.innerHTML = debugDiv.innerHTML.replace(/å‹•ä½œ: .*/, `å‹•ä½œ: ${act}`);
        }

        // --- 6. èŠå¤©å®¤ UI è¼”åŠ©å‡½å¼ ---
        function formatText(text) {
            let safeText = text.replace(/&/g, "&amp;")
                               .replace(/</g, "&lt;")
                               .replace(/>/g, "&gt;")
                               .replace(/"/g, "&quot;")
                               .replace(/'/g, "&#039;");

            safeText = safeText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, linkText, url) => {
                return `<a href="${url}" target="_blank" rel="noopener noreferrer">${linkText}</a>`;
            });

            safeText = safeText.replace(/\n/g, "<br>");
            return safeText;
        }

        function addMessage(text, type) {
            const chatDisplay = document.getElementById('chat-display');
            const div = document.createElement('div');
            div.className = `message message-${type}`;
            div.innerHTML = formatText(text);
            chatDisplay.appendChild(div);
            chatDisplay.scrollTop = chatDisplay.scrollHeight;
            return div;
        }

        function removeMessage(element) {
            if(element && element.parentNode) {
                element.parentNode.removeChild(element);
            }
        }

        // --- 7. Gemini API & è¨Šæ¯è™•ç† ---
        const statusDot = document.getElementById('status-dot');
        const statusMsg = document.getElementById('status-msg');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const muteBtn = document.getElementById('mute-btn');
        const chatDisplay = document.getElementById('chat-display');

        let availableVoices = [];
        window.speechSynthesis.onvoiceschanged = () => {
            availableVoices = window.speechSynthesis.getVoices();
        };

        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            if (isMuted) {
                muteBtn.innerText = 'ğŸ”‡';
                muteBtn.classList.add('muted');
                window.speechSynthesis.cancel(); 
                isSpeaking = false; 
                if(currentVrm) currentVrm.expressionManager.setValue('aa', 0); 
            } else {
                muteBtn.innerText = 'ğŸ”Š';
                muteBtn.classList.remove('muted');
            }
        });

        async function testApiConnection() {
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: "Hello" }] }] })
                });
                if (response.ok) {
                    statusDot.classList.add('status-connected');
                    statusMsg.innerText = "çŸ¥è­˜åº«å·²è¼‰å…¥";
                    enableChat();
                } else throw new Error();
            } catch (e) {
                statusDot.classList.add('status-error');
                statusMsg.innerText = "é€£ç·šå¤±æ•—";
            }
        }

        function enableChat() {
            userInput.disabled = false; sendBtn.disabled = false; userInput.focus();
        }

        async function handleSendMessage() {
            const text = userInput.value.trim();
            if (!text) return;

            userInput.value = ''; 
            userInput.disabled = true; 
            sendBtn.disabled = true;
            
            addMessage(text, 'user');
            const loadingMsg = addMessage("Thinking...", 'system');
            chatHistory.push({ role: "user", parts: [{ text: text }] });

            // --- çµ„è£ Promptï¼šå¤–éƒ¨è¨­å®š + å¤–éƒ¨çŸ¥è­˜ + é è¨­å‚™æ¡ˆ ---
            
            // 1. åŸºç¤è¨­å®š (å¦‚æœ Prompt.txt è®€å¤±æ•—ï¼Œå°±ç”¨é€™å€‹)
            const fallbackPrompt = `
                You are a virtual AI character.
                Reply in Traditional Chinese (zh-TW) by default.
                Output strictly JSON:
                { "text": "response", "emotion": "neutral", "action": "none", "duration": 0 }
            `;

            let finalSystemInstruction = "";

            if (externalSystemPrompt && externalSystemPrompt.length > 0) {
                // ä½¿ç”¨å¤–éƒ¨è®€å–çš„è¨­å®š
                finalSystemInstruction += externalSystemPrompt;
            } else {
                // ä½¿ç”¨å…§å»ºå‚™æ¡ˆ
                finalSystemInstruction += fallbackPrompt;
            }

            // 2. æ³¨å…¥çŸ¥è­˜åº«
            if (externalKnowledge && externalKnowledge.length > 0) {
                finalSystemInstruction += "\n\n====== KNOWLEDGE BASE (HIGH PRIORITY) ======\n";
                finalSystemInstruction += externalKnowledge;
                finalSystemInstruction += "\n============================================\n";
            }

            // 3. æ³¨å…¥å¼·åˆ¶å„ªå…ˆæ¬ŠæŒ‡ä»¤
            finalSystemInstruction += `
                
                ã€CRITICAL PRIORITY INSTRUCTIONSã€‘
                1. First, CHECK the "KNOWLEDGE BASE" section above. If the answer is there, use it directly.
                2. If not found in Knowledge Base, use the "Google Search" tool to find the latest info.
                3. If neither has the answer, use your internal knowledge.
                
                REMEMBER: You MUST return a JSON object as defined in the prompt.
            `;

            try {
                const safeHistory = chatHistory.filter(msg => {
                    const part = msg.parts[0];
                    return part && typeof part.text === 'string' && part.text.trim() !== '' && part.text !== '...';
                });

                const payload = {
                    contents: safeHistory,
                    systemInstruction: { parts: [{ text: finalSystemInstruction }] },
                    tools: [{ google_search: {} }],
                };

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();
                if (data.error) throw new Error(data.error.message);

                removeMessage(loadingMsg);

                let rawText = data.candidates[0].content.parts[0].text;
                let result = { text: "", emotion: 'neutral', action: 'none', duration: 0 };

                try {
                    const jsonMatch = rawText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        result = JSON.parse(jsonMatch[0]);
                    } else {
                        result.text = rawText;
                        result.emotion = 'neutral';
                    }
                } catch (e) {
                    console.warn("JSON Parse Failed", e);
                    result.text = rawText;
                }

                if (!result.text) result.text = result.response || result.message || rawText;

                // è£œå……çš„æƒ…ç·’åˆ¤æ–·é‚è¼¯ (ä»¥é˜² AI å¿˜è¨˜å›å‚³ JSON)
                const lowerText = result.text.toLowerCase();
                const inputLower = text.toLowerCase();

                if (inputLower.match(/(é–‰|çœ¨|close|blink).*(å³|right)/)) {
                    result.action = "blink_right"; result.duration = 3000;
                } else if (inputLower.match(/(é–‰|çœ¨|close|blink).*(å·¦|left)/)) {
                    result.action = "blink_left"; result.duration = 3000;
                }

                if (!result.emotion || result.emotion === 'neutral') {
                    if (lowerText.match(/(å“€å‚·|æ‚²å‚·|é›£é|ç—›è‹¦|sad|cry)/)) result.emotion = 'sad';
                    else if (lowerText.match(/(é–‹å¿ƒ|å¿«æ¨‚|happy|joy)/)) result.emotion = 'happy';
                    else if (lowerText.match(/(ç”Ÿæ°£|æ†¤æ€’|angry)/)) result.emotion = 'angry';
                    else if (lowerText.match(/(é©šè¨|surprised)/)) result.emotion = 'surprised';
                }

                const finalResponseText = result.text && result.text.length > 0 ? result.text : "ï¼ˆNodï¼‰";

                chatHistory.push({ role: "model", parts: [{ text: finalResponseText }] });
                
                addMessage(finalResponseText, 'ai');
                setEmotion(result.emotion || 'neutral');
                if (result.action && result.action !== 'none') {
                    triggerAction(result.action, result.duration || 2000);
                }

                speak(finalResponseText);

            } catch (error) {
                console.error("Error:", error);
                removeMessage(loadingMsg);
                addMessage("System Busy...", 'system');
            } finally {
                userInput.disabled = false; sendBtn.disabled = false; userInput.focus();
            }
        }

        // èªéŸ³åˆæˆ (ä¸­è‹±æ··é›œéæ¿¾)
        function speak(text) {
            if (isMuted) return;

            const cleanText = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '');
            const textWithoutSymbols = cleanText.replace(/[\x00-\x7F]/g, '')
                                                .replace(/[\u3000-\u303F\uFF00-\uFFEF\u2000-\u206F]/g, '');
            const hasChinese = /[\u4e00-\u9fa5]/.test(cleanText);

            let targetLang = '';
            if (hasChinese) {
                targetLang = 'zh-TW';
            } else {
                if (textWithoutSymbols.trim().length === 0) {
                    targetLang = 'en-US';
                } else {
                    console.log("åµæ¸¬åˆ°éä¸­è‹±æ–‡å…§å®¹ï¼ŒéœéŸ³");
                    return; 
                }
            }

            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(cleanText);
            
            utterance.lang = targetLang;
            utterance.rate = 1.0; 
            utterance.pitch = 0.8; 

            if (availableVoices.length === 0) availableVoices = window.speechSynthesis.getVoices();
            
            let voiceTarget = targetLang === 'zh-TW' ? 'zh' : 'en';
            let voice = availableVoices.find(v => v.lang.includes(voiceTarget) && v.name.includes('Google'));
            if (!voice) voice = availableVoices.find(v => v.lang.includes(voiceTarget));
            if (voice) utterance.voice = voice;

            utterance.onstart = () => { isSpeaking = true; };
            utterance.onend = () => { isSpeaking = false; if(currentVrm) currentVrm.expressionManager.setValue('aa', 0); };
            window.speechSynthesis.speak(utterance);
        }

        sendBtn.addEventListener('click', handleSendMessage);
        userInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleSendMessage(); });

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                window.speechSynthesis.cancel();
                isSpeaking = false;
                if (currentVrm) currentVrm.expressionManager.setValue('aa', 0);
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
